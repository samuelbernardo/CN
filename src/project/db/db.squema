--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

--
-- Name: consultaa(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION consultaa() RETURNS TABLE(nome character varying, tituloe character varying, total_faixas bigint, total_duracao interval)
    LANGUAGE sql
    AS $$

select nome, tituloE , count(numero) as total_faixas, sum(duracao) as total_duracao 
from (Edicao as e natural join Faixa natural join Musica) join Banda using (idB)
where e.ano = 2011
group by idB, nome, tituloE
$$;


ALTER FUNCTION public.consultaa() OWNER TO ist167074;

--
-- Name: consultab(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION consultab() RETURNS TABLE(nome character varying, tituloe character varying, total_faixas_singles bigint)
    LANGUAGE sql
    AS $$
select b.nome, f.tituloE, count(distinct f.tituloM)
from banda as b, faixa as f, single as s
where f.tituloM = s.tituloM
  and b.idB = f.idB
  and b.idB = s.idB
group by b.nome, f.tituloE
having count(distinct f.tituloM) >= all
	(select count (distinct f.tituloM)
	 from faixa as f, single as s
	 where f.tituloM = s.tituloM
	   and f.idB = s.idB
	 group by f.idB, f.tituloE
	)
$$;


ALTER FUNCTION public.consultab() OWNER TO ist167074;

--
-- Name: consultac(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION consultac() RETURNS TABLE(nome character varying, tituloe character varying)
    LANGUAGE sql
    AS $$
select b.nome, a.tituloE
from banda as b, album as a
where b.idB = a.idB
  and not exists (
	(select f.idB
	 from faixa as f, live as l
 	 where a.tituloE = f.tituloE
           and a.idB = f.idB
	   and a.idB = l.idB
	   and (l.tituloM = f.tituloM  -- verificar se a faixa e musica live
	   or l.tituloMO = f.tituloM)) -- verificar se existe versao live daquela musica
  )
$$;


ALTER FUNCTION public.consultac() OWNER TO ist167074;

--
-- Name: consultad(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION consultad() RETURNS TABLE(nome character varying, tituloe character varying)
    LANGUAGE sql
    AS $$
select distinct b.nome, a.tituloE
from banda as b, album as a, concerto as c
where a.idB = c.idB
  and a.idB = b.idB
  and not exists ((
	select f.idB, f.tituloE, f.numero
	from faixa as f
 	where a.tituloE = f.tituloE
      and a.idB = f.idB)
        except(
		select f2.idB, f2.tituloE, f2.numero
		from faixa as f2, live as l
		where f2.idB = a.idB
          and f2.idB = l.idB
          and f2.tituloM = l.tituloM
		  and l.data = c.data
          and l.hora = c.hora
		  )
 )
$$;


ALTER FUNCTION public.consultad() OWNER TO ist167074;

--
-- Name: verifica_delete_album_proc(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION verifica_delete_album_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	alter table faixa disable trigger verifica_delete_faixa;
	alter table faixa disable trigger verifica_update_faixa;
	delete from faixa where faixa.tituloE = old.tituloE and old.idB = faixa.idB;
	alter table faixa enable trigger verifica_delete_faixa;
	alter table faixa enable trigger verifica_update_faixa;
	return old;
end $$;


ALTER FUNCTION public.verifica_delete_album_proc() OWNER TO ist167074;

--
-- Name: verifica_delete_faixa_proc(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION verifica_delete_faixa_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
		if not exists (select *            
       		from faixa as f, album as a
               	where old.idB = a.idB
		and old.tituloE = a.tituloE      
		and old.idB = f.idB
               	and f.tituloE = old.tituloE
       	 	and old.tituloE = f.tituloM                    -- garantir restricao
               	and old.numero != f.numero)                     -- faixa difrente daquele que vai ser alterada
	then raise exception 'Nao e possivel apagar a faixa pelo que existe um album que depende dela.';
	else return old;
	end if;
end $$;


ALTER FUNCTION public.verifica_delete_faixa_proc() OWNER TO ist167074;

--
-- Name: verifica_delete_single_proc(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION verifica_delete_single_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	if exists(select *				-- existe outro single que possa substuir?
		from single as s
		where old.idB = s.idB
		and old.tituloE != s.tituloE
		and old.tituloM = s.tituloM)
	then return old;
	end if;
	if not exists (select *                        	-- existe um algum que dependa do single?
        	from album as a
                	where old.idB = a.idB
			and a.tituloE = old.tituloM)
	then return old;
        else raise exception 'Nao e possivel apagar o single pelo que existe um album que depende dele.';
        end if;
end $$;


ALTER FUNCTION public.verifica_delete_single_proc() OWNER TO ist167074;

--
-- Name: verifica_insert_album_proc(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION verifica_insert_album_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if exists(select *
                        from single as s
                        where new.idB = s.idB and new.tituloE = s.tituloM )
                then	insert into faixa values (new.idB, new.tituloE, 1, new.tituloE); return new;
        else    delete from album where album.idB = new.idB and album.tituloE = new.tituloE;
		raise exception 'Nao existe nenhum single com titulo da sua musica igual ao titulo que deseja colocar no album. Impossivel adicionar album.';
        end if;
end $$;


ALTER FUNCTION public.verifica_insert_album_proc() OWNER TO ist167074;

--
-- Name: verifica_update_album_proc(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION verifica_update_album_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if exists (select *                                             -- garantir restricao
                        from faixa as f, album as a, single as s
                        where new.idB = f.idB
                        and f.idB = s.idB
                        and f.tituloE = new.tituloE
                        and new.tituloE = f.tituloM
                        and f.tituloE = s.tituloM)
                then return new;
        else raise exception 'Nao e possivel alterar o album pelo que nao existe o duplo (faixa, single) com o mesmo titulo de (musica, edicao).';
        end if;
end $$;


ALTER FUNCTION public.verifica_update_album_proc() OWNER TO ist167074;

--
-- Name: verifica_update_faixa_proc(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION verifica_update_faixa_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if new.idB = old.idB and new.tituloM = old.tituloM and old.tituloE = new.tituloE       -- verificar se nao se alterou informacao sensivel
                then return new;
        else
                if exists (select *                                             -- verificar se depois do update continua a ser garantida a RI
                                from faixa as f
                                where old.idB = f.idB                           -- mesma banda que a faixa antiga
                                and f.tituloE = old.tituloE
                                and old.tituloE = f.tituloM                    -- garantir restricao
                                and old.numero != f.numero)                     -- faixa difrente daquele que vai ser alterada
                then return new;
                else raise exception 'Nao e possivel alterar a faixa pelo que existe um album que depende dela.';
                end if;
        end if;
end $$;


ALTER FUNCTION public.verifica_update_faixa_proc() OWNER TO ist167074;

--
-- Name: verifica_update_single_proc(); Type: FUNCTION; Schema: public; Owner: ist167074
--

CREATE FUNCTION verifica_update_single_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if new.idB = old.idB and new.tituloM = old.tituloM                     -- verificar se nao se alterou informacao sensivel (so altera a edicao)
                then return new;
        else
                if exists (select *                                             -- verificar se depois do update continua a ser garantida a RI
                                from faixa as f, album as a, single as s
                                where s.idB = f.idB
                                and s.idB = a.idB
                                and f.tituloM = old.tituloM
                                and f.tituloM = f.tituloE
                                and f.tituloE = a.tituloE
				and f.tituloM = s.tituloM
                                and s.tituloE != old.tituloE)
                then return new;
                else raise exception 'Nao e possivel alterar o single pelo que existe um album que depende dele.';
                end if;
        end if;
end $$;


ALTER FUNCTION public.verifica_update_single_proc() OWNER TO ist167074;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: logs; Type: TABLE; Schema: public; Owner: ist167074; Tablespace: 
--

CREATE TABLE logs (
    date character varying(255) NOT NULL,
    id character varying(255) NOT NULL,
    number character varying(255) NOT NULL,
    value character varying(255)
);


ALTER TABLE public.logs OWNER TO ist167074;

--
-- Name: logs_pkey; Type: CONSTRAINT; Schema: public; Owner: ist167074; Tablespace: 
--

ALTER TABLE ONLY logs
    ADD CONSTRAINT logs_pkey PRIMARY KEY (date, id, number);


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- PostgreSQL database dump complete
--

